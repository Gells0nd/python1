import functools
import time

# Декоратор для функции без аргументов: @staticmethod


# Декоратор @staticmethod используется для определения статического метода в Python. Статический метод не привязан ни к экземплярам класса, ни к самому классу и не имеет доступа к атрибутам экземпляров. Он обычно используется для создания методов, которые связаны с классом в целом, а не с его конкретными экземплярами.

# Зачем нужен статический метод без аргументов?

# Логическая связь с классом: Статический метод может быть связан с классом и выполнять логически связанные операции, которые не требуют доступа к состоянию экземпляров. Это может быть полезно для группировки связанных функций в классе.

# Изоляция от состояния экземпляров: Статический методы не имеют доступа к данным экземпляров, и, таким образом, они не могут их изменять. Это может быть полезным, если вы хотите создать метод, который выполняет какие-то операции, но не влияет на состояние объектов.

# Повторное использование: Статические методы могут быть вызваны без создания экземпляра класса, что делает их более доступными для повторного использования вне контекста объекта.

class MathUtils:
    @staticmethod
    def double(x):
        return x * 2


# Пример использования
result = MathUtils.double(5)  # Возвращает 10


# --------------------------------------------------------------------------------------------------------

# Декоратор для функции с двумя аргументами: @classmethod

# Связанный с классом функционал: Метод класса может выполнять операции, которые связаны с самим классом, а не с конкретными экземплярами. Например, он может использоваться для создания экземпляров класса на основе переданных параметров, что полезно, когда у вас есть несколько способов создания объектов.

# Общие операции: Если у вас есть операции, которые должны выполняться для всех объектов данного класса и имеют общий контекст, метод класса может быть удобным способом их реализации. Он может использоваться для обработки данных, которые относятся к классу в целом.

# Интерфейс для класса: Методы класса могут служить важной частью интерфейса класса, предоставляя специфическую функциональность, доступную через сам класс, а не через его экземпляры.

class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height

    @classmethod
    def create_square(cls, side_length):
        return cls(side_length, side_length)


# Пример использования
square = Rectangle.create_square(4)


# --------------------------------------------------------------------------------------------------------

# Декоратор для функции с неизвестным количеством аргументов: @staticmethod или *args/**kwargs

# @staticmethod: Этот декоратор используется, когда метод не зависит от состояния экземпляра и не требует доступа к атрибутам экземпляра или класса. Статический метод вызывается через класс и не имеет доступа к атрибутам self (для экземпляра) или cls (для класса). Он может принимать произвольное количество аргументов, но они не связаны с экземпляром и классом напрямую.

# Использование *args и **kwargs в сигнатуре функции позволяет ей принимать произвольное количество аргументов (позиционных и именованных) без предварительного определения их числа и имён. Это удобно, когда вам неизвестно заранее, сколько аргументов может быть передано функции, и когда эти аргументы могут иметь разные имена.

def log_args(func):
    @staticmethod
    def wrapper(*args, **kwargs):
        print(
            f"Вызвана функция {func.__name__} с аргументами {args} и ключевыми аргументами {kwargs}")
        return func(*args, **kwargs)
    return wrapper


@log_args
def add(x, y):
    return x + y


# Пример использования
# Выводит "Вызвана функция add с аргументами (3, 5) и ключевыми аргументами {}"
result = add(3, 5)

# --------------------------------------------------------------------------------------------------------

# Декоратор, который перенял всю документацию от декорируемой функции: functools.wraps

# Сохранение документации: Один из основных применений functools.wraps - это сохранение документации (docstring) из оригинальной функции. Это полезно для того, чтобы пользователи могли получить информацию о функции через help() или в инструментах автодокументирования.

# Сохранение имени функции: Если вы не используете functools.wraps, имя обернутой функции может отличаться от имени декорируемой функции. Использование wraps позволяет сохранить имя функции, что полезно для отладки и анализа кода.

# Сохранение атрибутов и метаданных: wraps также копирует другие метаданные функции, такие как атрибуты класса и другие атрибуты, которые могли быть установлены для оригинальной функции.


def my_decorator(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        """Документация для обертки."""
        print("Что-то делается перед вызовом функции")
        result = func(*args, **kwargs)
        print("Что-то делается после вызова функции")
        return result
    return wrapper


@my_decorator
def example_function():
    """Документация для функции."""
    print("Функция выполняется")


# Пример использования
help(example_function)  # Выводит документацию функции и обертки

# --------------------------------------------------------------------------------------------------------

# Декоратор в виде класса: @classmethod


# Декоратор в виде класса @classmethod используется для определения метода класса в Python. Метод класса связан с самим классом, а не с экземплярами класса. Он имеет доступ к атрибутам класса, но не имеет доступа к атрибутам экземпляров.

# Зачем нужен декоратор @classmethod:

# Связанный с классом функционал: Метод класса может выполнять операции, которые связаны с самим классом, а не с конкретными экземплярами. Это полезно, когда у вас есть несколько способов создания объектов, операции, связанные с классом в целом, или логика, которая должна быть общей для всех объектов данного класса.

# Общие операции: Если у вас есть операции, которые должны выполняться для всех объектов данного класса и имеют общий контекст, метод класса может быть удобным способом их реализации.

# Интерфейс для класса: Методы класса могут служить важной частью интерфейса класса, предоставляя специфическую функциональность, доступную через сам класс, а не через его экземпляры.

class TimerDecorator:
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        start_time = time.time()
        result = self.func(*args, **kwargs)
        end_time = time.time()
        print(f"Время выполнения функции: {end_time - start_time} секунд")
        return result


@TimerDecorator
def slow_function():
    time.sleep(2)


# Пример использования
slow_function()  # Покажет время выполнения функции

# --------------------------------------------------------------------------------------------------------
